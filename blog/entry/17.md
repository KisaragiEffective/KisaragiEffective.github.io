# What is JIT Compile?
## はじめに
辞書的な定義は[jawp](https://ja.wikipedia.org/wiki/実行時コンパイラ)を参照。

## どうやるの
実行する直前により低レベル (※Ruby → C言語など) な表現にアセンブルする、終わり！ｗ

## 適応的コンパイル
ただ、それを全部に適用するとメモリとかディスクを無駄遣いすることになるので、プロファイリングに基づいてJITするのが適応的コンパイル。JavaのHotSpotなどが当てはまる。

### どうやるの
具体的には変数や関数の型や値をプロファイリングしておく。次に、各々のJITコンパイラの戦略で (例: **一番実行される頻度が高そうなセクション**に) 特殊化したコード (つまり、定数畳み込みやデッドコード削除など一般的な手法がここでは使える！)を注入する。ここで、特殊化したコードは特殊化する前のコードよりも実行時間が短いのが常である。そして、特殊化したコードを呼び出せるならそちらを呼び出す。それ以外のときは従来どおりのコードを実行する。

### 何が嬉しい？
JavaScriptなどの型が表には出てこないような言語で、変数やプロパティ、関数の型が分かると、上記で記したように高速化が期待できる。Javaなどの静的型付けであっても、(java.util.Calendarの定数のように) 静的にとり得る値の集合が静的に決定できなくてもJITでとり得る値は1から7とわかれば、それに応じた命令を生成できる。
とはいえ、値の集合がより狭く、静的に証明できる列挙型やシールドクラスが利用できるなら積極的にそちらを利用すべきだ。そうすることで、JITフェーズではなく、コンパイルフェーズでの最適化が期待できるためである。
つまり、

```java
public static final int HOGE = 1;
public static final int PIYO = 2;
public static final int FUGA = 4;
```

とするのではなく、

```java
public enum SomeFlag {
  HOGE,
  PIYO,
  FUGA,
  ;
}
```

とするのだ。

